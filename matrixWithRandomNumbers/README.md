# Массив, заполненный случайными уникальными числами

Нужно заполнить массив 5 на 7 случайными уникальными числами от 1 до 1000.
Вывести получившийся массив и суммы по строкам и по столбцам.

## Решение:



Поэтому можно решить данную задачу, выбирая случайные уникальные числа каждый раз из сужающегося набора значений.

### Способы получить случайное целое в php:

| Функция                                                                                               | Требования | Особенности                                                      |
|-------------------------------------------------------------------------------------------------------|------------|------------------------------------------------------------------|
| [rand](https://www.php.net/manual/ru/function.rand)                                                   | php4..php8 | начиная с 7.1.0 - синоним mt_rand                                |
| [mt_rand](https://www.php.net/manual/ru/function.mt-rand)                                             | php4..php8 |                                                                  |
| [random_int](https://www.php.net/manual/ru/function.random-int)                                       | php7..php8 | криптобезопасна, поэтому возможно более требовательна к ресурсам |
| [array_rand](https://www.php.net/manual/ru/function.array-rand)                                       | php4..php8 | внутренняя реализация родственна mt_rand -  на вихре Мерсена     |
| [shuffle](https://www.php.net/manual/ru/function.shuffle.php)                                         | php4..php8 | перемешивание массива на вихре Мерсена                           |
| [Random\Randomizer::getInt](https://www.php.net/manual/ru/random-randomizer.getint.php)               | >= 8.2.0   | Появилась в свежем релизе php                                    |
| [Random\Randomizer::shuffleArray](https://www.php.net/manual/ru/random-randomizer.shufflearray.php)   | >=  8.2.0  |                                                                  |
| [Random\Randomizer::pickArrayKeys](https://www.php.net/manual/ru/random-randomizer.pickarraykeys.php) | >=  8.2.0  |                                                                  |

Есть несколько вариантов реализации алгоритма:
1. [[NAIVE][]] запуск генератора случайных чисел без связи с уже заполненными ячейками, отсеивая полученные значения по факту, в рекурсивной функции.
   В худшем случае мы получаем непредсказуемое время работы скрипта и такую же сложность алгоритма.
2. [[SHIFT](src/RandomUniqueIntGenerator/Shift.php)] при повторном выпадении уже выпадавшего ранее значения - можно сместиться вверх к следующему за ним значению, а если 
оно находится за пределами заданного интервала значений - то брать с начала интервала. (эту гипотезу нужно исследовать на 
случайность распределения). Так как выбор по arr[$key] стремится к O(1) - отброс уже существующих значений будет достаточно эффективным.
3. выбирать в два этапа - сначала один из неиспользованных интервалов, а потом значение из этого интервала. Есть также опасение
в нарушении случайного распределения в этом случае, за счет того, что неодинаковые по количеству элементов группы выбираются
на первом этапе равновероятно.
4. [[LOTO](src/RandomUniqueIntGenerator/Loto.php)] выбирать из массива, который первоначально 
наполнить полным диапазоном значений. Примерно так делают, когда играют в лото.

По форматированию вывода - выводим для cli ascII таблицу по образцу:
```text
 -------------- Σ --
  | 1 | 2 | 3 | 6  |
 ------------------
  | 3 | 4 | 5 | 12 |
 -------------------
Σ | 4 | 6 | 8 |    |
 -------------------
```

В ходе реализации по алгоритму **LOTO** - выяснилось ряд особенностей. Алгоритм ограничен по максимальному количеству 
элементов массива - проверяется при создании генератора из входящих условий. И это ограничение - не PHP_INT_MAX как можно
было бы предположить, и не 2147483647 - а 1073741822 (подобрал эмпирически). На других системах значение другое - например 
на https://3v4l.org/#live - 67108862, при том что PHP_INT_MAX=2147483647. Также алгоритм 
сильно ограничен по объему памяти, поскольку именно ее объем лимитирует на самом деле количество элементов.